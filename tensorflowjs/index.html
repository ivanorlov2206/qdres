<html>
  <head>
    <meta charset="utf-8">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@2.0.0/dist/tf.min.js"></script>
    <script src="https://docs.opencv.org/3.4.0/opencv.js"></script>

    <canvas id="canv" width="224" height="224" style="background-color: #000000;"></canvas><br>
    <!--<canvas id="canv" width="128" height="64" style="background-color: #000000;"></canvas><br>-->
    <button id="send">Определить</button><button id="clear">Стереть</button><br><br>
    <span style="font-size: 25dp" id="result">Загрузка модели...</span><br>
    <span style="font-size: 25dp" id="time"></span><br><br>
  </head>
  <body style="touch-action: none;">
    <script>
      var model;
      (async () => {
        model = await tf.loadLayersModel('http://127.0.0.1:8000/model/model.json');
        document.getElementById("result").innerHTML = "";
        var base_image = new Image();
        base_image.src = 'test.png';
        base_image.onload = function(){
          context.drawImage(base_image, 0, 0);
        }


        var canvas = document.getElementById("canv");
          var context = canvas.getContext("2d");

          var w = canvas.width;
          var h = canvas.height;
          context.fillStyle = "black";
          context.fillRect(0, 0, w, h);

          var mouse = {x: 0, y: 0};
          var draw = false;

          canvas.addEventListener("pointerdown", function(e) {
              mouse.x = e.pageX - this.offsetLeft;
              mouse.y = e.pageY - this.offsetTop;
              draw = true;
          });
          canvas.addEventListener("pointermove", function(e) {
              if (draw == true) {
                  mouse.x = e.pageX - this.offsetLeft;
                  mouse.y = e.pageY - this.offsetTop;

                  context.fillStyle = "white";
                  context.beginPath();
                  context.ellipse(mouse.x, mouse.y, 6, 6, 0, 0, 2 * Math.PI);
                  context.fill();
              }
          });
          canvas.addEventListener("pointerup", function(e) {
              mouse.x = e.pageX - this.offsetLeft;
              mouse.y = e.pageY - this.offsetTop;
              draw = false;
          });
          var clear = document.getElementById("clear");
          clear.addEventListener("click", function() {
              context.fillStyle = "black";
              context.fillRect(0, 0, w, h);
          });

          function crop_and_center_image(img) {
            let w = img.cols;
            let h = img.rows;
            var nw, nh;
            var sz = 28;

            if (w > h) {
              nh = sz / w * h;
              nw = sz;
              console.log(nw, nh);
            } else {
              nw = sz / h * w;
              nh = sz;
            }
            cv.resize(img, img, new cv.Size(nw, nh), 0, 0, cv.INTER_AREA);
            var iy = (sz - nh) / 2;
            var ix = (sz - nw) / 2;
            console.log(ix, iy);
            var nimg = new cv.Mat(sz, sz, cv.CV_8U, new cv.Scalar(0));
            //cv.imshow('canv3', nimg);

            nimg.setTo(new cv.Scalar(0, 0, 0));
            console.time("resize");
            for (var y = iy; y < iy + nh; y++) {
              for (var x = ix; x < ix + nw; x++) {
                if (img.ucharPtr(y - iy, x - ix)[0] != 0) {
                  nimg.ucharPtr(y, x)[0] = img.ucharPtr(y - iy, x - ix)[0];
                  nimg.ucharPtr(y, x)[1] = img.ucharPtr(y - iy, x - ix)[1];
                  nimg.ucharPtr(y, x)[2] = img.ucharPtr(y - iy, x - ix)[2];
                }
              }
            }
            console.timeEnd("resize");
            //let mask = new cv.Mat(224, 224, cv.CV_8U, new cv.Scalar(0));

            return nimg;
          }

          function my_find_contours(im) {
            console.time("mycontours");
            var mnx = im.cols, mny = im.rows, mxx = 0, mxy = 0;

            for (var y = 0; y < im.rows; y++) {
              for (var x = 0; x < im.cols; x++) {
                if (im.ucharPtr(y, x)[0] != 0) {
                  if (x < mnx)
                    mnx = x;
                  if (x > mxx)
                    mxx = x;
                  if (y < mny)
                    mny = y;
                  if (y > mxy)
                    mxy = y;
                }
              }
            }
            console.log(mnx, mny, mxx, mxy);
            let imm = new cv.Mat();
            imm = im.roi(new cv.Rect(mnx, mny, mxx - mnx, mxy - mny));
            console.timeEnd("mycontours");
            return imm;
          }

          function find_contours(im) {
            console.time("contours");
            let blackboard_gray = new cv.Mat();
            cv.cvtColor(im, blackboard_gray, cv.COLOR_BGR2GRAY);
            let blur1 = new cv.Mat();
            cv.medianBlur(blackboard_gray, blur1, 15);
            let thresh1 = new cv.Mat();
            cv.threshold(blur1, thresh1, 127, 255, cv.THRESH_BINARY);


            let contours = new cv.MatVector();
            let hierarchy = new cv.Mat();
            // You can try more different parameters
            cv.findContours(thresh1, contours, hierarchy, cv.RETR_TREE, cv.CHAIN_APPROX_NONE);
            for (let i = 0; i < contours.size(); ++i) {
              console.log(cv.contourArea(contours.get(i)));
              if (cv.contourArea(contours.get(i)) > 2000) {
                let rect = cv.boundingRect(contours.get(i));
                let imm = new cv.Mat();
                imm = blackboard_gray.roi(rect);
                console.timeEnd("contours");
                return imm
              }
            }
          }

          var snd = document.getElementById("send");
          snd.addEventListener("click", function() {
              var t0 = performance.now();
              console.time("process");
              let src = cv.imread('canv');
              let dst = new cv.Mat();
              let imm = new cv.Mat();
              imm = my_find_contours(src);
              //crop_and_center_image(src)
              //cv.imshow('canv3', crop_and_center_image(src));
              dst = crop_and_center_image(imm);
              //cv.imshow('canv2', dst);
              var arr = [];
              for (var i = 0; i < 28; i++) {
                var la = [];
                for (var j = 0; j < 28; j++) {
                  var d = dst.ucharPtr(i, j)[0];
                  if (d > 0)
                    la.push(1);
                  else {
                    la.push(0);
                  }
                }
                arr.push(la);
              }
              console.timeEnd("process");
              console.log(model);
              var classes = ['book', 'sun', 'banana', 'apple', 'bowtie', 'ice cream', 'eye', 'square', 'cup', 'door', 'sword', 'star', 'fish', 'donut', 'mountain'];
              console.time("classificate");
              let mx = tf.argMax(model.predict(tf.tensor2d(arr).reshape([-1, 28, 28, 1])), 1);
              var res = classes[Array.from(mx.dataSync())[0]];
              document.getElementById("result").innerHTML = "This is " + res;
              var t1 = performance.now();
              document.getElementById("time").innerHTML = "Execution time: " + (t1 - t0) + " ms";
              console.timeEnd("classificate");
          });
      })();


    </script>
  </body>

</html>
